"use strict";(self.webpackChunktkbook=self.webpackChunktkbook||[]).push([[2356],{3254:e=>{e.exports=JSON.parse('{"version":{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"link","label":"Introduction","href":"/tk_book/docs/","docId":"Intro","unlisted":false},{"type":"category","label":"Best Practice","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Best Practices In Java Development","href":"/tk_book/docs/Best Practice/Best Practices In Java Development","docId":"Best Practice/Best Practices In Java Development","unlisted":false},{"type":"link","label":"Collaboration Best Practices","href":"/tk_book/docs/Best Practice/Collaboration Best Practices","docId":"Best Practice/Collaboration Best Practices","unlisted":false},{"type":"link","label":"Developer\'s best practices","href":"/tk_book/docs/Best Practice/Developer\'S Best Practices","docId":"Best Practice/Developer\'S Best Practices","unlisted":false},{"type":"link","label":"Development Best practices","href":"/tk_book/docs/Best Practice/Development Best practices","docId":"Best Practice/Development Best practices","unlisted":false},{"type":"link","label":"GitHub Workflow","href":"/tk_book/docs/Best Practice/GitHub Workflow","docId":"Best Practice/GitHub Workflow","unlisted":false},{"type":"link","label":"Unit Tests","href":"/tk_book/docs/Best Practice/Unit Tests","docId":"Best Practice/Unit Tests","unlisted":false}]},{"type":"category","label":"Errors","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"CannotCreateTransaction","href":"/tk_book/docs/Errors/Cannotcreatetransaction","docId":"Errors/Cannotcreatetransaction","unlisted":false},{"type":"link","label":"Entities","href":"/tk_book/docs/Errors/Ententies","docId":"Errors/Ententies","unlisted":false},{"type":"link","label":"Liquibase Checksum Validation Issue","href":"/tk_book/docs/Errors/Liquibase Checksum Validation Issue","docId":"Errors/Liquibase Checksum Validation Issue","unlisted":false},{"type":"link","label":"Problem In Line","href":"/tk_book/docs/Errors/Problem In Line","docId":"Errors/Problem In Line","unlisted":false},{"type":"link","label":"ZK UI Exception","href":"/tk_book/docs/Errors/Zk Ui Exception","docId":"Errors/Zk Ui Exception","unlisted":false}]},{"type":"category","label":"Java & Spring","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Comparing Objects in Java","href":"/tk_book/docs/Java & Spring/Comparing Objects","docId":"Java & Spring/Comparing Objects","unlisted":false},{"type":"link","label":"Repository, Manager, and Test","href":"/tk_book/docs/Java & Spring/Creating new Entity","docId":"Java & Spring/Creating new Entity","unlisted":false},{"type":"link","label":"Dao","href":"/tk_book/docs/Java & Spring/Dao","docId":"Java & Spring/Dao","unlisted":false},{"type":"link","label":"Dependencies","href":"/tk_book/docs/Java & Spring/Dependencies","docId":"Java & Spring/Dependencies","unlisted":false},{"type":"link","label":"Entites","href":"/tk_book/docs/Java & Spring/Entites","docId":"Java & Spring/Entites","unlisted":false},{"type":"link","label":"HQL or JPQL?","href":"/tk_book/docs/Java & Spring/HQL vs JPQL","docId":"Java & Spring/HQL vs JPQL","unlisted":false},{"type":"link","label":"Java Modifiers Order","href":"/tk_book/docs/Java & Spring/Java Modifiers Order","docId":"Java & Spring/Java Modifiers Order","unlisted":false},{"type":"link","label":"JPQL Documentation","href":"/tk_book/docs/java/jpql","docId":"Java & Spring/jpql","unlisted":false},{"type":"link","label":"Java Modifiers Order","href":"/tk_book/docs/Java & Spring/Modifier","docId":"Java & Spring/Modifier","unlisted":false},{"type":"link","label":"Named Parameters vs. Positional Parameters","href":"/tk_book/docs/Java & Spring/Named Parameters vs. Positional Parameters","docId":"Java & Spring/Named Parameters vs. Positional Parameters","unlisted":false},{"type":"link","label":"Resource Bundles in Java","href":"/tk_book/docs/Java & Spring/ResourceBundle","docId":"Java & Spring/ResourceBundle","unlisted":false},{"type":"link","label":"Testing DAO Classes:","href":"/tk_book/docs/Java & Spring/Unit Tests","docId":"Java & Spring/Unit Tests","unlisted":false}]},{"type":"category","label":"Libraries","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Apache Poi","href":"/tk_book/docs/Libraries/Apache Poi","docId":"Libraries/Apache Poi","unlisted":false},{"type":"link","label":"Liquibase","href":"/tk_book/docs/Libraries/Liquibase","docId":"Libraries/Liquibase","unlisted":false}]},{"type":"category","label":"Security","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Security Audit","href":"/tk_book/docs/Security/Sescurity Audit","docId":"Security/Sescurity Audit","unlisted":false},{"type":"link","label":"SQL Injection Overview","href":"/tk_book/docs/Security/Sql Injection","docId":"Security/Sql Injection","unlisted":false}]},{"type":"category","label":"Tumorotek","collapsible":true,"collapsed":true,"items":[{"type":"category","label":"Busniess Logic","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"User Rights and Conditions Documentation","href":"/tk_book/docs/Tumorotek/Busniess Logic/User Rights","docId":"Tumorotek/Busniess Logic/User Rights","unlisted":false}]},{"type":"category","label":"General","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Coding Starndards","href":"/tk_book/docs/Tumorotek/General/Coding Starndards","docId":"Tumorotek/General/Coding Starndards","unlisted":false},{"type":"link","label":"ConfigManager","href":"/tk_book/docs/Tumorotek/General/Config","docId":"Tumorotek/General/Config","unlisted":false},{"type":"link","label":"Dao","href":"/tk_book/docs/Tumorotek/General/Dao","docId":"Tumorotek/General/Dao","unlisted":false},{"type":"link","label":"Dev And Env Setup","href":"/tk_book/docs/Tumorotek/General/Dev And Env Setup","docId":"Tumorotek/General/Dev And Env Setup","unlisted":false},{"type":"link","label":"Introduction","href":"/tk_book/docs/Tumorotek/General/Entity","docId":"Tumorotek/General/Entity","unlisted":false},{"type":"link","label":"Genericdaojpa","href":"/tk_book/docs/Tumorotek/General/Genericdaojpa","docId":"Tumorotek/General/Genericdaojpa","unlisted":false},{"type":"link","label":"Introduction","href":"/tk_book/docs/Tumorotek/General/Introduction","docId":"Tumorotek/General/Introduction","unlisted":false},{"type":"link","label":"Liquibase","href":"/tk_book/docs/Tumorotek/General/Liquibase","docId":"Tumorotek/General/Liquibase","unlisted":false},{"type":"link","label":"Testing DAO Classes:","href":"/tk_book/docs/Tumorotek/General/Unit Tests","docId":"Tumorotek/General/Unit Tests","unlisted":false}]},{"type":"category","label":"Managers","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"EnceinteManager Methods","href":"/tk_book/docs/Tumorotek/Managers/EncienteManager","docId":"Tumorotek/Managers/EncienteManager","unlisted":false}]}]},{"type":"category","label":"ZK","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Controller Annotations","href":"/tk_book/docs/ZK/Annotations","docId":"ZK/Annotations","unlisted":false},{"type":"link","label":"Buttons","href":"/tk_book/docs/ZK/Buttons","docId":"ZK/Buttons","unlisted":false},{"type":"link","label":"Communication Between Components in ZK Framework","href":"/tk_book/docs/ZK/Communication Between Components","docId":"ZK/Communication Between Components","unlisted":false},{"type":"link","label":"Understanding Data Binding in MVC vs. MVVM with ZK Wire Component","href":"/tk_book/docs/ZK/Data Binding","docId":"ZK/Data Binding","unlisted":false},{"type":"link","label":"Debug In Zk","href":"/tk_book/docs/ZK/Debug In Zk","docId":"ZK/Debug In Zk","unlisted":false},{"type":"link","label":"ZK Framework: Event Handling and Operations","href":"/tk_book/docs/ZK/Event Handling And Operations","docId":"ZK/Event Handling And Operations","unlisted":false},{"type":"link","label":"Event Handling","href":"/tk_book/docs/ZK/Event Handling","docId":"ZK/Event Handling","unlisted":false},{"type":"link","label":"Annotations","href":"/tk_book/docs/ZK/Generic Forward Composer","docId":"ZK/Generic Forward Composer","unlisted":false},{"type":"link","label":"Grid","href":"/tk_book/docs/ZK/Grid","docId":"ZK/Grid","unlisted":false},{"type":"link","label":"ZK Framework: Listbox Component Manual","href":"/tk_book/docs/ZK/Listbox","docId":"ZK/Listbox","unlisted":false},{"type":"link","label":"MVC vs MVVM","href":"/tk_book/docs/ZK/Mvc Vs Mvvm","docId":"ZK/Mvc Vs Mvvm","unlisted":false},{"type":"link","label":"Opening and Handling Modals","href":"/tk_book/docs/ZK/Opening And Handling Modals","docId":"ZK/Opening And Handling Modals","unlisted":false},{"type":"link","label":"Reusable Components","href":"/tk_book/docs/ZK/Reusable Components","docId":"ZK/Reusable Components","unlisted":false},{"type":"link","label":"UI Refresh in ZK Framework: MVC vs MVVM","href":"/tk_book/docs/ZK/Ui Update","docId":"ZK/Ui Update","unlisted":false},{"type":"link","label":"ZUL Page Lifecycle","href":"/tk_book/docs/ZK/ZUL Page Lifecycle","docId":"ZK/ZUL Page Lifecycle","unlisted":false},{"type":"link","label":"Zul File","href":"/tk_book/docs/ZK/Zul file","docId":"ZK/Zul file","unlisted":false}]}]},"docs":{"Best Practice/Best Practices In Java Development":{"id":"Best Practice/Best Practices In Java Development","title":"Best Practices In Java Development","description":"Best Practices in Java Development","sidebar":"tutorialSidebar"},"Best Practice/Collaboration Best Practices":{"id":"Best Practice/Collaboration Best Practices","title":"Collaboration Best Practices","description":"- Clear Communication: Regularly update the team on project progress using scheduled team meetings or collaboration tools to maintain transparent communication.","sidebar":"tutorialSidebar"},"Best Practice/Developer\'S Best Practices":{"id":"Best Practice/Developer\'S Best Practices","title":"Developer\'s best practices","description":"These principles aim to enhance code quality, reduce complexity, and facilitate collaboration among developers.","sidebar":"tutorialSidebar"},"Best Practice/Development Best practices":{"id":"Best Practice/Development Best practices","title":"Development Best practices","description":"- DRY (Don\'t Repeat Yourself):","sidebar":"tutorialSidebar"},"Best Practice/GitHub Workflow":{"id":"Best Practice/GitHub Workflow","title":"GitHub Workflow","description":"GitHub Workflow","sidebar":"tutorialSidebar"},"Best Practice/Unit Tests":{"id":"Best Practice/Unit Tests","title":"Unit Tests","description":"When working on the Tumorotek project, it is essential to write unit tests for your Data Access Object (DAO) classes and Services (Managers).","sidebar":"tutorialSidebar"},"Errors/Cannotcreatetransaction":{"id":"Errors/Cannotcreatetransaction","title":"CannotCreateTransaction","description":"transaction_problem","sidebar":"tutorialSidebar"},"Errors/Ententies":{"id":"Errors/Ententies","title":"Entities","description":"Accessing Inaccessible Attribute","sidebar":"tutorialSidebar"},"Errors/Liquibase Checksum Validation Issue":{"id":"Errors/Liquibase Checksum Validation Issue","title":"Liquibase Checksum Validation Issue","description":"Checksum validation issues in Liquibase can be resolved by updating the checksums in the DATABASECHANGELOG table to match the modified changesets. It\'s crucial to carefully review and document any intentional changes made to the changelog files to maintain consistency in the database schema evolution process.","sidebar":"tutorialSidebar"},"Errors/Problem In Line":{"id":"Errors/Problem In Line","title":"Problem In Line","description":"When having this error you should check your ZUL for the source of the problem. What is surprising is that in some cases the source of the problem is not the ZUL, it\'s the controller. But how can you tell?","sidebar":"tutorialSidebar"},"Errors/Zk Ui Exception":{"id":"Errors/Zk Ui Exception","title":"ZK UI Exception","description":"ui_exception","sidebar":"tutorialSidebar"},"Intro":{"id":"Intro","title":"Introduction","description":"The purpose of this technical document is to provide developers and non-developers with a comprehensive guide on best practices for a specific project. It aims to offer practical advice, recommendations, and guidelines to ensure efficient development, implementation, and maintenance of the project. This document is written in a simple and accessible manner, allowing both technical and non-technical persons to understand and apply the best practices outlined within.","sidebar":"tutorialSidebar"},"Java & Spring/Comparing Objects":{"id":"Java & Spring/Comparing Objects","title":"Comparing Objects in Java","description":"Comparing Primitive Types, Java Objects, and Custom Objects in Java: Best Practices","sidebar":"tutorialSidebar"},"Java & Spring/Creating new Entity":{"id":"Java & Spring/Creating new Entity","title":"Repository, Manager, and Test","description":"When working with an older Spring project that doesn\'t use the annotation-based configuration typical in Spring Boot, you would need to configure your DAO, Entity, and Service in XML files.","sidebar":"tutorialSidebar"},"Java & Spring/Dao":{"id":"Java & Spring/Dao","title":"Dao","description":"This tutorial will guide you how to create and work with a new DAO.","sidebar":"tutorialSidebar"},"Java & Spring/Dependencies":{"id":"Java & Spring/Dependencies","title":"Dependencies","description":"In a Java project managed with Apache Maven, dependencies play a critical role in bringing external libraries and components into your project. Ensuring that these dependencies are up-to-date is crucial for various reasons, including security, bug fixes, and overall project stability. This section will discuss the significance of working with updated dependencies, the potential disadvantages, and highlight the situation in the TK project where many dependencies require updates.","sidebar":"tutorialSidebar"},"Java & Spring/Entites":{"id":"Java & Spring/Entites","title":"Entites","description":"Entities in a Spring project represent the business objects or data structures that are persisted to a database.","sidebar":"tutorialSidebar"},"Java & Spring/HQL vs JPQL":{"id":"Java & Spring/HQL vs JPQL","title":"HQL or JPQL?","description":"In the Tumorotek project, we use JPQL rather than HQL. But what exactly is the difference between them, and how can we distinguish between the two?","sidebar":"tutorialSidebar"},"Java & Spring/Java Modifiers Order":{"id":"Java & Spring/Java Modifiers Order","title":"Java Modifiers Order","description":"In Java, the order of modifiers follows a specific convention that enhances readability and consistency. Modifiers control the visibility, behavior, and other properties of classes, methods, fields, and constructors. Below is the standard order of modifiers in Java declarations:","sidebar":"tutorialSidebar"},"Java & Spring/jpql":{"id":"Java & Spring/jpql","title":"JPQL Documentation","description":"Please note that these are general indicators and not definitive proof of whether HQL or JPQL is being used. To be certain, you may need to check the project\'s dependencies and the specific ORM configuration.","sidebar":"tutorialSidebar"},"Java & Spring/Modifier":{"id":"Java & Spring/Modifier","title":"Java Modifiers Order","description":"In Java, the order of modifiers follows a specific convention that enhances readability and consistency. Modifiers control the visibility, behavior, and other properties of classes, methods, fields, and constructors. Below is the standard order of modifiers in Java declarations:","sidebar":"tutorialSidebar"},"Java & Spring/Named Parameters vs. Positional Parameters":{"id":"Java & Spring/Named Parameters vs. Positional Parameters","title":"Named Parameters vs. Positional Parameters","description":"Named Parameters vs. Positional Parameters in JPA/Hibernate","sidebar":"tutorialSidebar"},"Java & Spring/ResourceBundle":{"id":"Java & Spring/ResourceBundle","title":"Resource Bundles in Java","description":"Resource bundles in Java are used to handle locale-specific objects, allowing programs to be easily localized, handle multiple locales simultaneously, and support additional locales as needed. This approach isolates locale-specific information, making the program code largely independent of the user\'s locale.","sidebar":"tutorialSidebar"},"Java & Spring/Unit Tests":{"id":"Java & Spring/Unit Tests","title":"Testing DAO Classes:","description":"1. Check Existing Test Class:","sidebar":"tutorialSidebar"},"Libraries/Apache Poi":{"id":"Libraries/Apache Poi","title":"Apache Poi","description":"Apache POI User Guide Manual","sidebar":"tutorialSidebar"},"Libraries/Liquibase":{"id":"Libraries/Liquibase","title":"Liquibase","description":"Liquibase is an open-source database-independent library for tracking, managing, and applying database schema changes. It allows you to version control your database schema, making it easier to deploy.","sidebar":"tutorialSidebar"},"Security/Sescurity Audit":{"id":"Security/Sescurity Audit","title":"Security Audit","description":"The objective of the code audit for SESAN was to identify potential vulnerabilities and their impacts on the specified scope, including the TK and Gatsbi projects. The audit aimed to uncover threats related to the application\'s design and interactions with external dependencies, analyze weaknesses in the source code and security implementation, and provide a corrective action plan to address identified vulnerabilities and guard against potential attack threats. Key stakeholders included Tania MAC-LUCKIE from GCS SESAN and Alexandra LEVRAT, Nicolas BOURRAS, and Remy FARULLI from Orange Cyberdefense, serving as the main points of contact.","sidebar":"tutorialSidebar"},"Security/Sql Injection":{"id":"Security/Sql Injection","title":"SQL Injection Overview","description":"SQL injection is a common and potentially devastating type of attack on web applications that use databases. It occurs when an attacker is able to manipulate the SQL query being executed by the application, often by inputting malicious SQL code through user inputs. This can lead to unauthorized access, data manipulation, and even complete compromise of the system.","sidebar":"tutorialSidebar"},"Tumorotek/Busniess Logic/User Rights":{"id":"Tumorotek/Busniess Logic/User Rights","title":"User Rights and Conditions Documentation","description":"This document provides guidelines on how to conditionally perform actions based on user rights within the system.","sidebar":"tutorialSidebar"},"Tumorotek/General/Coding Starndards":{"id":"Tumorotek/General/Coding Starndards","title":"Coding Starndards","description":"Coding Standards and Conventions","sidebar":"tutorialSidebar"},"Tumorotek/General/Config":{"id":"Tumorotek/General/Config","title":"ConfigManager","description":"ConfigManager is a configuration utility class used in Tumorotek to centralize and manage various constants and configurations. It stores predefined values such as database types, MIME types for file exports, entity IDs, and other commonly used constants. This approach helps streamline application configuration and ensures consistency across the project by reducing hardcoding and duplicative definitions.","sidebar":"tutorialSidebar"},"Tumorotek/General/Dao":{"id":"Tumorotek/General/Dao","title":"Dao","description":"This tutorial will guide you how to create and work with a new DAO.","sidebar":"tutorialSidebar"},"Tumorotek/General/Dev And Env Setup":{"id":"Tumorotek/General/Dev And Env Setup","title":"Dev And Env Setup","description":"- Development Environment Setup","sidebar":"tutorialSidebar"},"Tumorotek/General/Entity":{"id":"Tumorotek/General/Entity","title":"Introduction","description":"This guide provides step-by-step instructions for developers to create a new entity in a Spring project. Entities in a Spring project represent the business objects or data structures that are persisted to a database. Creating a new entity involves defining the entity, creating a corresponding table in the DB, and integrating it into the Spring application.","sidebar":"tutorialSidebar"},"Tumorotek/General/Genericdaojpa":{"id":"Tumorotek/General/Genericdaojpa","title":"Genericdaojpa","description":"All or most of the DAO interfaces in Tumorotek extends GenericDaoJpa.","sidebar":"tutorialSidebar"},"Tumorotek/General/Introduction":{"id":"Tumorotek/General/Introduction","title":"Introduction","description":"Project Overview","sidebar":"tutorialSidebar"},"Tumorotek/General/Liquibase":{"id":"Tumorotek/General/Liquibase","title":"Liquibase","description":"Config","sidebar":"tutorialSidebar"},"Tumorotek/General/Unit Tests":{"id":"Tumorotek/General/Unit Tests","title":"Testing DAO Classes:","description":"1. Check Existing Test Class:","sidebar":"tutorialSidebar"},"Tumorotek/Managers/EncienteManager":{"id":"Tumorotek/Managers/EncienteManager","title":"EnceinteManager Methods","description":"- findByIdManager: Retrieves an Enceinte object by its ID.","sidebar":"tutorialSidebar"},"ZK/Annotations":{"id":"ZK/Annotations","title":"Controller Annotations","description":"The package an annotation comes from helps determine its primary use case within the ZK framework.","sidebar":"tutorialSidebar"},"ZK/Buttons":{"id":"ZK/Buttons","title":"Buttons","description":"Buttons are a fundamental UI component in ZK applications, allowing users to trigger actions and interact with the system. This document covers the attributes of the button component in ZK and how to handle button events in both MVC (Model-View-Controller) and MVVM (Model-View-ViewModel) patterns.","sidebar":"tutorialSidebar"},"ZK/Communication Between Components":{"id":"ZK/Communication Between Components","title":"Communication Between Components in ZK Framework","description":"see my forum question","sidebar":"tutorialSidebar"},"ZK/Data Binding":{"id":"ZK/Data Binding","title":"Understanding Data Binding in MVC vs. MVVM with ZK Wire Component","description":"When developing modern web applications, the choice of architectural patterns and frameworks significantly impacts the way data is managed and bound to the UI. The ZK Wire component is a feature of the ZK framework that simplifies the process of binding data between the user interface and the underlying data models or view models. It automates the process of synchronizing data, reducing the amount of boilerplate code and increasing development efficiency.","sidebar":"tutorialSidebar"},"ZK/Debug In Zk":{"id":"ZK/Debug In Zk","title":"Debug In Zk","description":"How to Debug in ZK Using the Built-in ZK Debugger","sidebar":"tutorialSidebar"},"ZK/Event Handling":{"id":"ZK/Event Handling","title":"Event Handling","description":"In ZK Framework, events play a crucial role in capturing user interactions and triggering corresponding actions. This guide provides an overview of handling events in ZK, emphasizing the general principles applicable to various scenarios.","sidebar":"tutorialSidebar"},"ZK/Event Handling And Operations":{"id":"ZK/Event Handling And Operations","title":"ZK Framework: Event Handling and Operations","description":"The ZK Framework, a popular Java-based framework for building rich web applications, provides extensive support for event handling and managing operations. Understanding how to effectively utilize ZK\'s event handling mechanisms, including manual event firing, synchronized long operations, asynchronous operations, and the event queue, is crucial for developing responsive and efficient applications. This document will provide an overview of these concepts and their implementation within the ZK framework.","sidebar":"tutorialSidebar"},"ZK/Generic Forward Composer":{"id":"ZK/Generic Forward Composer","title":"Annotations","description":"Controller","sidebar":"tutorialSidebar"},"ZK/Grid":{"id":"ZK/Grid","title":"Grid","description":"Grids in ZK are powerful components for displaying organized data. This guide will walk you through how to work with a Grid, separate data into pages, and implement sorting. We will also explore accessing controller variables in the view and using the master-detail feature.","sidebar":"tutorialSidebar"},"ZK/Listbox":{"id":"ZK/Listbox","title":"ZK Framework: Listbox Component Manual","description":"The Listbox component in ZK Framework is a versatile UI component used to display a list of items in a tabular format. It is highly customizable, supports data binding, and can be used for both simple and complex data representations. This manual provides a comprehensive overview of the Listbox component, including its subcomponents, attributes, events, data binding capabilities, and practical examples.","sidebar":"tutorialSidebar"},"ZK/Mvc Vs Mvvm":{"id":"ZK/Mvc Vs Mvvm","title":"MVC vs MVVM","description":"The ZK framework provides support for both MVC and MVVM architectures.","sidebar":"tutorialSidebar"},"ZK/Opening And Handling Modals":{"id":"ZK/Opening And Handling Modals","title":"Opening and Handling Modals","description":"Opening modals, passing parameters, and receiving data back in ZK can be done efficiently in both MVC and MVVM patterns. However, MVVM provides a more modern and clean approach, especially for complex applications where separation of concerns and data binding are critical.","sidebar":"tutorialSidebar"},"ZK/Reusable Components":{"id":"ZK/Reusable Components","title":"Reusable Components","description":"Reusable Components","sidebar":"tutorialSidebar"},"ZK/Ui Update":{"id":"ZK/Ui Update","title":"UI Refresh in ZK Framework: MVC vs MVVM","description":"In ZK, managing UI updates and refreshing the view in response to data changes is a critical aspect of building dynamic web applications. The approach to UI refresh can vary significantly depending on whether you are using the MVC (Model-View-Controller) pattern or the MVVM (Model-View-ViewModel) pattern. This document provides a detailed comparison of UI refresh strategies in both architectural patterns.","sidebar":"tutorialSidebar"},"ZK/Zul file":{"id":"ZK/Zul file","title":"Zul File","description":"Window Configuration:","sidebar":"tutorialSidebar"},"ZK/ZUL Page Lifecycle":{"id":"ZK/ZUL Page Lifecycle","title":"ZUL Page Lifecycle","description":"The ZK framework provides two key annotations, @init and @AfterCompose, for handling component initialization and ViewModel setup in ZK-based applications. While both methods serve the purpose of initializing components and assigning variables in the ViewModel, they differ in terms of when they are executed during the ZUL page lifecycle.","sidebar":"tutorialSidebar"}}}}')}}]);