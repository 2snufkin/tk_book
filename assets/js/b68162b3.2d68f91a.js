"use strict";(self.webpackChunktkbook=self.webpackChunktkbook||[]).push([[455],{9365:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>c});var t=s(4848),i=s(8453);const o={},r="Communication Between Components in ZK Framework",a={id:"ZK/Communication Between Components",title:"Communication Between Components in ZK Framework",description:"see my forum question",source:"@site/docs/ZK/Communication Between Components.md",sourceDirName:"ZK",slug:"/ZK/Communication Between Components",permalink:"/tk_book/docs/ZK/Communication Between Components",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Buttons",permalink:"/tk_book/docs/ZK/Buttons"},next:{title:"Understanding Data Binding in MVC vs. MVVM with ZK Wire Component",permalink:"/tk_book/docs/ZK/Data Binding"}},l={},c=[{value:"Communication via Global Command",id:"communication-via-global-command",level:2},{value:"Example:",id:"example",level:3},{value:"Step 1: Define the Components and Command",id:"step-1-define-the-components-and-command",level:4},{value:"Step 2: Create the ViewModels",id:"step-2-create-the-viewmodels",level:4},{value:"Explanation:",id:"explanation",level:3},{value:"3. Communication and Data Passing in ZK MVVM",id:"3-communication-and-data-passing-in-zk-mvvm",level:3},{value:"3.1. <strong>Passing Data Between ViewModels: MVVM -&gt; MVVM</strong>",id:"31-passing-data-between-viewmodels-mvvm---mvvm",level:4},{value:"1. Event Posting in ZK MVC",id:"1-event-posting-in-zk-mvc",level:3},{value:"1.1. <strong>Posting Events Between Controllers</strong>",id:"11-posting-events-between-controllers",level:4},{value:"1.2. <strong>Using Global Events</strong>",id:"12-using-global-events",level:4},{value:"2. Event Posting in ZK MVVM",id:"2-event-posting-in-zk-mvvm",level:3},{value:"2.1. <strong>Posting Events Between ViewModels</strong>",id:"21-posting-events-between-viewmodels",level:4},{value:"2.2. <strong>Using EventQueues for Asynchronous Communication</strong>",id:"22-using-eventqueues-for-asynchronous-communication",level:4},{value:"EventQueues vs. Global Events in ZK Framework",id:"eventqueues-vs-global-events-in-zk-framework",level:3},{value:"1. Global Events",id:"1-global-events",level:3},{value:"1.1. <strong>How Global Events Work</strong>",id:"11-how-global-events-work",level:4},{value:"1.2. <strong>Use Cases for Global Events</strong>",id:"12-use-cases-for-global-events",level:4},{value:"1.3. <strong>Limitations of Global Events</strong>",id:"13-limitations-of-global-events",level:4},{value:"2. EventQueues",id:"2-eventqueues",level:3},{value:"2.1. <strong>How EventQueues Work</strong>",id:"21-how-eventqueues-work",level:4},{value:"2.2. <strong>Use Cases for EventQueues</strong>",id:"22-use-cases-for-eventqueues",level:4},{value:"2.3. <strong>Advantages of EventQueues</strong>",id:"23-advantages-of-eventqueues",level:4},{value:"3. Key Differences",id:"3-key-differences",level:3},{value:"4. Summary",id:"4-summary",level:3},{value:"Communicating Across Different Views or Windows in ZK",id:"communicating-across-different-views-or-windows-in-zk",level:3},{value:"1. <strong>Communication Across Views or Windows in ZK</strong>",id:"1-communication-across-views-or-windows-in-zk",level:3},{value:"1.1 <strong>Same Page Communication</strong>",id:"11-same-page-communication",level:4},{value:"1.2 <strong>Cross-Window Communication</strong>",id:"12-cross-window-communication",level:4},{value:"2. <strong>Impact of MVVM and MVC Patterns on Communication</strong>",id:"2-impact-of-mvvm-and-mvc-patterns-on-communication",level:3},{value:"2.1 <strong>MVC Pattern</strong>",id:"21-mvc-pattern",level:4},{value:"2.2 <strong>MVVM Pattern</strong>",id:"22-mvvm-pattern",level:4},{value:"3. <strong>Best Practices</strong>",id:"3-best-practices",level:3},{value:"Examples of <code>ExecutionQueue</code> Usage in ZK",id:"examples-of-executionqueue-usage-in-zk",level:3},{value:"<strong>1. Basic Example: Cross-Window Communication</strong>",id:"1-basic-example-cross-window-communication",level:4},{value:"<strong>Step 1: Sending a Message to the ExecutionQueue</strong>",id:"step-1-sending-a-message-to-the-executionqueue",level:5},{value:"<strong>Step 2: Listening for Messages in Another Window</strong>",id:"step-2-listening-for-messages-in-another-window",level:5},{value:"<strong>Explanation:</strong>",id:"explanation-1",level:5},{value:"<strong>2. Advanced Example: User-Specific Communication</strong>",id:"2-advanced-example-user-specific-communication",level:4},{value:"<strong>Step 1: Creating a User-Specific Queue</strong>",id:"step-1-creating-a-user-specific-queue",level:5},{value:"<strong>Step 2: Subscribing to the User-Specific Queue</strong>",id:"step-2-subscribing-to-the-user-specific-queue",level:5},{value:"<strong>Explanation:</strong>",id:"explanation-2",level:5},{value:"<strong>3. Real-Time Notifications Example</strong>",id:"3-real-time-notifications-example",level:4},{value:"<strong>Step 1: Publishing Collaborative Updates</strong>",id:"step-1-publishing-collaborative-updates",level:5},{value:"<strong>Step 2: Subscribing to Updates for a Specific Document</strong>",id:"step-2-subscribing-to-updates-for-a-specific-document",level:5},{value:"<strong>Explanation:</strong>",id:"explanation-3",level:5},{value:"<strong>Summary</strong>",id:"summary",level:3},{value:"<strong>How to Make MVVM and MVC Communicate</strong>",id:"how-to-make-mvvm-and-mvc-communicate",level:3},{value:"<strong>1. Use Events Instead of Global Commands</strong>",id:"1-use-events-instead-of-global-commands",level:4},{value:"<strong>Step 1: Posting a Custom Event in MVVM</strong>",id:"step-1-posting-a-custom-event-in-mvvm",level:5},{value:"<strong>Step 2: Listening for the Event in MVC</strong>",id:"step-2-listening-for-the-event-in-mvc",level:5},{value:"<strong>Summary</strong>",id:"summary-1",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"communication-between-components-in-zk-framework",children:"Communication Between Components in ZK Framework"})}),"\n",(0,t.jsxs)(n.p,{children:["see my forum question\n",(0,t.jsx)(n.a,{href:"https://forum.zkoss.org/question/115304/communication-between-viewmodel-and-composer/",children:"https://forum.zkoss.org/question/115304/communication-between-viewmodel-and-composer/"})]}),"\n",(0,t.jsx)(n.h2,{id:"communication-via-global-command",children:"Communication via Global Command"}),"\n",(0,t.jsx)(n.p,{children:"Sometimes, components need to communicate across different views or windows. This can be done using global commands."}),"\n",(0,t.jsx)(n.h3,{id:"example",children:"Example:"}),"\n",(0,t.jsx)(n.p,{children:"Assume you have a list of items in one window and want to display the selected item details in another window."}),"\n",(0,t.jsx)(n.h4,{id:"step-1-define-the-components-and-command",children:"Step 1: Define the Components and Command"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:"\x3c!-- Item List Window --\x3e\n<window viewModel=\"@id('vm') @init('com.example.ItemListViewModel')\">\n    <listbox model=\"@load(vm.items)\" onSelect=\"@command('itemSelected')\" />\n</window>\n\n\x3c!-- Item Detail Window --\x3e\n<window viewModel=\"@id('vm') @init('com.example.ItemDetailViewModel')\">\n    <label value=\"@load(vm.selectedItemDetails)\" />\n</window>\n"})}),"\n",(0,t.jsx)(n.h4,{id:"step-2-create-the-viewmodels",children:"Step 2: Create the ViewModels"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"ItemListViewModel.java"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'public class ItemListViewModel {\n    private List<String> items = Arrays.asList("Item 1", "Item 2", "Item 3");\n\n    public List<String> getItems() {\n        return items;\n    }\n\n    @GlobalCommand\n    @NotifyChange("selectedItemDetails")\n    public void itemSelected(@BindingParam("selected") String selectedItem) {\n        Map<String, Object> args = new HashMap<>();\n        args.put("selected", selectedItem);\n        BindUtils.postGlobalCommand(null, null, "updateDetails", args);\n    }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"ItemDetailViewModel.java"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'public class ItemDetailViewModel {\n    private String selectedItemDetails;\n\n    @GlobalCommand("updateDetails")\n    @NotifyChange("selectedItemDetails")\n    public void updateDetails(@BindingParam("selected") String selectedItem) {\n        this.selectedItemDetails = "Details for " + selectedItem;\n    }\n\n    public String getSelectedItemDetails() {\n        return selectedItemDetails;\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"explanation",children:"Explanation:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"@GlobalCommand"}),": Defines a command that can be called from any view."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"@BindingParam"}),": Passes parameters to the command."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"BindUtils.postGlobalCommand"}),": Triggers a global command, allowing communication across different ViewModels."]}),"\n"]}),"\n",(0,t.jsx)(n.h1,{id:"communication-and-data-passing-in-zk-framework-mvc-and-mvvm-approaches",children:"Communication and Data Passing in ZK Framework: MVC and MVVM Approaches"}),"\n",(0,t.jsxs)(n.ol,{start:"2",children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Using the Execution Context"}),": ZK's ",(0,t.jsx)(n.code,{children:"Execution"})," class allows controllers to share data via attributes."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'public class FirstController extends GenericForwardComposer<Component> {\n    public void onClick$button(Event event) {\n        String data = "Hello from FirstController!";\n        Executions.getCurrent().setAttribute("sharedData", data);\n    }\n}\n\npublic class SecondController extends GenericForwardComposer<Component> {\n    public void doAfterCompose(Component comp) throws Exception {\n        super.doAfterCompose(comp);\n        String data = (String) Executions.getCurrent().getAttribute("sharedData");\n        // Handle the data\n    }\n}\n'})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Event-Based Communication"}),": ZK allows you to use custom events to pass data between controllers."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'public class FirstController extends GenericForwardComposer<Component> {\n    public void onClick$button(Event event) {\n        String data = "Hello from FirstController!";\n        Events.postEvent("onDataPass", secondController.getSelf(), data);\n    }\n}\n\npublic class SecondController extends GenericForwardComposer<Component> {\n    public void onDataPass(Event event) {\n        String data = (String) event.getData();\n        // Handle the data\n    }\n}\n'})}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"3-communication-and-data-passing-in-zk-mvvm",children:"3. Communication and Data Passing in ZK MVVM"}),"\n",(0,t.jsx)(n.p,{children:"In the MVVM pattern, communication and data passing are primarily handled via data binding and command binding. The ViewModel is the central component that connects the view and the model."}),"\n",(0,t.jsxs)(n.h4,{id:"31-passing-data-between-viewmodels-mvvm---mvvm",children:["3.1. ",(0,t.jsx)(n.strong,{children:"Passing Data Between ViewModels: MVVM -> MVVM"})]}),"\n",(0,t.jsx)(n.p,{children:"In ZK MVVM, ViewModels do not directly interact with each other. Instead, they communicate through shared services, events, or via the execution context."}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Shared Services"}),": You can create a shared service class that multiple ViewModels can use to pass data."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'public class SharedService {\n    private String sharedData;\n    public String getSharedData() { return sharedData; }\n    public void setSharedData(String data) { this.sharedData = data; }\n}\n\npublic class FirstViewModel {\n    private SharedService sharedService;\n    public void someMethod() {\n        sharedService.setSharedData("Hello from FirstViewModel");\n    }\n}\n\npublic class SecondViewModel {\n    private SharedService sharedService;\n    public void someMethod() {\n        String data = sharedService.getSharedData();\n        // Handle the data\n    }\n}\n'})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Event-Based Communication"}),": ZK MVVM supports the use of events to pass data between ViewModels."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'public class FirstViewModel {\n    @Command\n    public void sendData() {\n        BindUtils.postGlobalCommand(null, null, "receiveData", Collections.singletonMap("data", "Hello from FirstViewModel"));\n    }\n}\n\npublic class SecondViewModel {\n    @GlobalCommand\n    @NotifyChange("data")\n    public void receiveData(@BindingParam("data") String data) {\n        this.data = data;\n    }\n}\n'})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Execution Context"}),": Similar to MVC, the ",(0,t.jsx)(n.code,{children:"Execution"})," context can be used to share data between ViewModels."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'public class FirstViewModel {\n    @Command\n    public void sendData() {\n        Executions.getCurrent().setAttribute("sharedData", "Hello from FirstViewModel");\n    }\n}\n\npublic class SecondViewModel {\n    @Init\n    public void init() {\n        String data = (String) Executions.getCurrent().getAttribute("sharedData");\n        // Handle the data\n    }\n}\n'})}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h1,{id:"communication-using-event-posting-in-zk-framework",children:"Communication Using Event Posting in ZK Framework"}),"\n",(0,t.jsx)(n.p,{children:"Event posting is a powerful feature in the ZK framework that facilitates communication between components, controllers, and view models. In your current application, where event posting is utilized, it's essential to understand how this mechanism works in both MVC and MVVM contexts. This section will focus on how to effectively use event posting to pass data and communicate between different components."}),"\n",(0,t.jsx)(n.h3,{id:"1-event-posting-in-zk-mvc",children:"1. Event Posting in ZK MVC"}),"\n",(0,t.jsx)(n.p,{children:"In the MVC pattern, controllers manage the communication between the view and model. Event posting allows one controller to send events (including data) to another controller or component. Here\u2019s how you can implement this:"}),"\n",(0,t.jsxs)(n.h4,{id:"11-posting-events-between-controllers",children:["1.1. ",(0,t.jsx)(n.strong,{children:"Posting Events Between Controllers"})]}),"\n",(0,t.jsxs)(n.p,{children:["Controllers in ZK can use ",(0,t.jsx)(n.code,{children:"Events.postEvent()"})," to send custom events to other components, which can be another controller or any UI component. The receiving component listens for these events and processes the data."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// FirstController.java\npublic class FirstController extends GenericForwardComposer<Component> {\n    private Component anotherComponent; // Reference to the other component\n\n\n    public void onClick$sendButton(Event event) {\n        String data = "Data from FirstController";\n        // Post an event to another component\n        Events.postEvent(new Event("onCustomEvent", anotherComponent, data));\n    }\n}\n\n// SecondController.java\npublic class SecondController extends GenericForwardComposer<Component> {\n @Override\n    public void doAfterCompose(Component comp) throws Exception {\n        super.doAfterCompose(comp);\n\n        // Add an event listener for "onCustomEvent"\n        comp.addEventListener("onCustomEvent", new EventListener<Event>() {\n            @Override\n            public void onEvent(Event event) throws Exception {\n                String receivedData = (String) event.getData();\n                // Process the received data\n                System.out.println("Received data: " + receivedData);\n            }\n        });\n    }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"In this example:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"FirstController"})," posts an event named ",(0,t.jsx)(n.code,{children:'"onCustomEvent"'})," to ",(0,t.jsx)(n.code,{children:"anotherComponent"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"SecondController"})," listens for this event and retrieves the data via ",(0,t.jsx)(n.code,{children:"event.getData()"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.h4,{id:"12-using-global-events",children:["1.2. ",(0,t.jsx)(n.strong,{children:"Using Global Events"})]}),"\n",(0,t.jsx)(n.p,{children:"ZK also supports global events, which are events broadcast to all interested listeners regardless of component hierarchy. This is useful when controllers or components are not directly related in the component tree."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// FirstController.java\npublic class FirstController extends GenericForwardComposer<Component> {\n\n    public void onClick$sendButton(Event event) {\n        String data = "Data from FirstController";\n        // Post a global event\n        Events.postEvent("onGlobalCustomEvent", null, data);\n    }\n}\n\n// SecondController.java\npublic class SecondController extends GenericForwardComposer<Component> {\n\n    public void doAfterCompose(Component comp) throws Exception {\n        super.doAfterCompose(comp);\n        // Listen for the global event\n        EventQueue<Event> eq = EventQueues.lookup("globalQueue");\n        eq.subscribe(new EventListener<Event>() {\n            public void onEvent(Event event) {\n                String receivedData = (String) event.getData();\n                // Handle the received data\n            }\n        });\n    }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"Here:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:'Events.postEvent("onGlobalCustomEvent", null, data);'})," posts a global event."]}),"\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"SecondController"})," subscribes to the global event queue and processes the received data."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"2-event-posting-in-zk-mvvm",children:"2. Event Posting in ZK MVVM"}),"\n",(0,t.jsx)(n.p,{children:"In the MVVM pattern, event posting is used similarly to MVC, but the communication happens between the ViewModel and the UI, or between different ViewModels."}),"\n",(0,t.jsxs)(n.h4,{id:"21-posting-events-between-viewmodels",children:["2.1. ",(0,t.jsx)(n.strong,{children:"Posting Events Between ViewModels"})]}),"\n",(0,t.jsxs)(n.p,{children:["ZK MVVM allows posting events using ",(0,t.jsx)(n.code,{children:"BindUtils.postGlobalCommand()"})," or ",(0,t.jsx)(n.code,{children:"BindUtils.postNotifyChange()"}),". This enables communication between different ViewModels."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// FirstViewModel.java\npublic class FirstViewModel {\n\n    @Command\n    public void sendData() {\n        String data = "Data from FirstViewModel";\n        // Post a global command\n        BindUtils.postGlobalCommand(null, null, "receiveData", Collections.singletonMap("data", data));\n    }\n}\n\n// SecondViewModel.java\npublic class SecondViewModel {\n\n    private String data;\n\n    @GlobalCommand\n    @NotifyChange("data")\n    public void receiveData(@BindingParam("data") String receivedData) {\n        this.data = receivedData;\n        // Handle the received data\n    }\n}\n'})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"FirstViewModel"})," posts a global command ",(0,t.jsx)(n.code,{children:'"receiveData"'})," with associated data."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"SecondViewModel"})," listens for this command using the ",(0,t.jsx)(n.code,{children:"@GlobalCommand"})," annotation and updates its state."]}),"\n"]}),"\n",(0,t.jsxs)(n.h4,{id:"22-using-eventqueues-for-asynchronous-communication",children:["2.2. ",(0,t.jsx)(n.strong,{children:"Using EventQueues for Asynchronous Communication"})]}),"\n",(0,t.jsx)(n.p,{children:"EventQueues provide a way to handle events asynchronously in MVVM, similar to the global events in MVC but with better control over the event flow."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// FirstViewModel.java\npublic class FirstViewModel {\n\n    @Command\n    public void sendData() {\n        String data = "Data from FirstViewModel";\n        // Post an event to the queue\n        EventQueues.lookup("customQueue", EventQueues.DESKTOP, true).publish(new Event("onCustomEvent", null, data));\n    }\n}\n\n// SecondViewModel.java\npublic class SecondViewModel {\n\n    @Init\n    public void init() {\n        // Subscribe to the event queue\n        EventQueues.lookup("customQueue", EventQueues.DESKTOP, true).subscribe(new EventListener<Event>() {\n            public void onEvent(Event event) {\n                String receivedData = (String) event.getData();\n                // Handle the received data\n            }\n        });\n    }\n}\n'})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"FirstViewModel"})," posts an event to a named event queue ",(0,t.jsx)(n.code,{children:'"customQueue"'}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"SecondViewModel"})," subscribes to this queue and processes events asynchronously."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"eventqueues-vs-global-events-in-zk-framework",children:"EventQueues vs. Global Events in ZK Framework"}),"\n",(0,t.jsxs)(n.p,{children:["In the ZK framework, both ",(0,t.jsx)(n.strong,{children:"EventQueues"})," and ",(0,t.jsx)(n.strong,{children:"Global Events"})," provide mechanisms for communicating between different components or controllers, but they serve slightly different purposes and offer distinct advantages depending on the use case. Below is a comparison of the two approaches to help you understand when to use each."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"1-global-events",children:"1. Global Events"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Global Events"})," in ZK are used to broadcast events across the entire application, regardless of the component hierarchy. This allows different parts of the application to listen for and respond to events, even if they are not directly related in the component tree."]}),"\n",(0,t.jsxs)(n.h4,{id:"11-how-global-events-work",children:["1.1. ",(0,t.jsx)(n.strong,{children:"How Global Events Work"})]}),"\n",(0,t.jsxs)(n.p,{children:["Global events are posted using the ",(0,t.jsx)(n.code,{children:"Events.postEvent()"})," method, where the event is typically associated with a component, but can also be broadcast globally without a specific target component."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// Posting a global event\nEvents.postEvent("onGlobalCustomEvent", null, data);\n'})}),"\n",(0,t.jsx)(n.p,{children:"Components or controllers that want to listen for these events subscribe to them by overriding event handlers or using annotations."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'public class MyController extends GenericForwardComposer<Component> {\n    public void doAfterCompose(Component comp) throws Exception {\n        super.doAfterCompose(comp);\n        // Listen for the global event\n        EventQueues.lookup("myGlobalEventQueue", EventQueues.APPLICATION, true).subscribe(new EventListener<Event>() {\n            public void onEvent(Event event) {\n                String receivedData = (String) event.getData();\n                // Handle the received data\n            }\n        });\n    }\n}\n'})}),"\n",(0,t.jsxs)(n.h4,{id:"12-use-cases-for-global-events",children:["1.2. ",(0,t.jsx)(n.strong,{children:"Use Cases for Global Events"})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Broadcasting Information Across the Application"}),": When you need to broadcast a message or data across different parts of your application, global events are a straightforward choice."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Simple Communication"}),": If your communication needs are relatively simple, global events provide an easy-to-implement solution."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Component-agnostic Communication"}),": Use global events when the listener does not need to be tied to a specific component."]}),"\n"]}),"\n",(0,t.jsxs)(n.h4,{id:"13-limitations-of-global-events",children:["1.3. ",(0,t.jsx)(n.strong,{children:"Limitations of Global Events"})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"No Asynchronous Processing"}),": Global events are handled synchronously, meaning they are processed immediately when fired, which could block the UI if the event handler contains heavy processing logic."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Potential for Tight Coupling"}),": Overusing global events can lead to tightly coupled components, making the application harder to maintain."]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"2-eventqueues",children:"2. EventQueues"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"EventQueues"})," in ZK provide a more advanced and flexible way to manage events. They allow events to be queued and processed asynchronously, which is particularly useful in complex applications where you need more control over event flow and processing."]}),"\n",(0,t.jsxs)(n.h4,{id:"21-how-eventqueues-work",children:["2.1. ",(0,t.jsx)(n.strong,{children:"How EventQueues Work"})]}),"\n",(0,t.jsx)(n.p,{children:"EventQueues allow you to create named queues where events can be published and subscribed to. These queues can operate in different scopes, such as desktop, session, or application, and they support asynchronous event processing."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// Publishing an event to an EventQueue\nEventQueues.lookup("myQueue", EventQueues.DESKTOP, true).publish(new Event("onCustomEvent", null, data));\n'})}),"\n",(0,t.jsx)(n.p,{children:"Listeners can subscribe to these queues to receive events asynchronously:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'EventQueues.lookup("myQueue", EventQueues.DESKTOP, true).subscribe(new EventListener<Event>() {\n    public void onEvent(Event event) {\n        String receivedData = (String) event.getData();\n        // Handle the received data\n    }\n});\n'})}),"\n",(0,t.jsxs)(n.h4,{id:"22-use-cases-for-eventqueues",children:["2.2. ",(0,t.jsx)(n.strong,{children:"Use Cases for EventQueues"})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Asynchronous Processing"}),": If you need to process events without blocking the UI thread, EventQueues provide a way to handle events asynchronously."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Complex Communication Scenarios"}),": When you have more complex event-driven communication requirements, such as handling events across different scopes (e.g., between different desktops or sessions), EventQueues are a better fit."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Decoupling Components"}),": EventQueues can help decouple components by allowing them to communicate through a loosely coupled event-driven mechanism."]}),"\n"]}),"\n",(0,t.jsxs)(n.h4,{id:"23-advantages-of-eventqueues",children:["2.3. ",(0,t.jsx)(n.strong,{children:"Advantages of EventQueues"})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Asynchronous Handling"}),": Events can be queued and processed in the background, improving application responsiveness."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Flexible Scoping"}),": EventQueues can operate in various scopes (desktop, session, application), giving you more control over where and how events are handled."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Event Throttling"}),": EventQueues support features like event throttling, which can help manage the rate at which events are processed."]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"3-key-differences",children:"3. Key Differences"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:(0,t.jsx)(n.strong,{children:"Feature"})}),(0,t.jsx)(n.th,{children:(0,t.jsx)(n.strong,{children:"Global Events"})}),(0,t.jsx)(n.th,{children:(0,t.jsx)(n.strong,{children:"EventQueues"})})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Processing Mode"})}),(0,t.jsx)(n.td,{children:"Synchronous"}),(0,t.jsx)(n.td,{children:"Asynchronous or Synchronous (based on configuration)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Scope"})}),(0,t.jsx)(n.td,{children:"Application-wide (can be broadcast globally)"}),(0,t.jsx)(n.td,{children:"Desktop, session, or application-wide (based on queue type)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Coupling"})}),(0,t.jsx)(n.td,{children:"Potential for tighter coupling due to direct event handling"}),(0,t.jsx)(n.td,{children:"Promotes loose coupling by decoupling event publishing and handling"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Complexity"})}),(0,t.jsx)(n.td,{children:"Simple to implement for straightforward communication"}),(0,t.jsx)(n.td,{children:"More complex, suitable for advanced scenarios"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Use Cases"})}),(0,t.jsx)(n.td,{children:"Simple, synchronous communication"}),(0,t.jsx)(n.td,{children:"Complex, asynchronous, or cross-scope communication"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Throttling"})}),(0,t.jsx)(n.td,{children:"Not supported"}),(0,t.jsx)(n.td,{children:"Supported (via queue configuration)"})]})]})]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"4-summary",children:"4. Summary"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use Global Events"})," when you need simple, synchronous communication across different parts of your application. They are easy to implement and sufficient for many straightforward use cases."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use EventQueues"})," when you require asynchronous event handling, need to manage events across different scopes, or want to decouple components to reduce tight coupling. EventQueues are more powerful and flexible, making them ideal for complex applications with sophisticated event-driven requirements."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Choosing between Global Events and EventQueues depends on the specific needs of your application, including the complexity of the communication patterns and the need for asynchronous processing."}),"\n",(0,t.jsx)(n.h3,{id:"communicating-across-different-views-or-windows-in-zk",children:"Communicating Across Different Views or Windows in ZK"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Introduction:"})}),"\n",(0,t.jsx)(n.p,{children:"ZK (ZKoss) is a popular Java-based framework that allows developers to build rich web applications without the need for extensive JavaScript coding. It supports both the MVC (Model-View-Controller) and MVVM (Model-View-ViewModel) design patterns, offering flexibility in how developers structure their applications. One common requirement in web applications is the need to communicate across different views or windows. This document explains the methods and best practices for achieving inter-window or inter-view communication in ZK, and examines the differences depending on whether the MVVM or MVC pattern is used."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.h3,{id:"1-communication-across-views-or-windows-in-zk",children:["1. ",(0,t.jsx)(n.strong,{children:"Communication Across Views or Windows in ZK"})]}),"\n",(0,t.jsxs)(n.p,{children:["In ZK, views or windows are typically represented as components (like ",(0,t.jsx)(n.code,{children:"Window"}),", ",(0,t.jsx)(n.code,{children:"Div"}),", ",(0,t.jsx)(n.code,{children:"Include"}),", etc.). Communication between them can be essential for creating interactive and dynamic user interfaces. The communication can occur in different ways, depending on whether the views are part of the same page or different pages, whether they are loaded in the same browser window, different tabs, or as modal/popup windows."]}),"\n",(0,t.jsxs)(n.h4,{id:"11-same-page-communication",children:["1.1 ",(0,t.jsx)(n.strong,{children:"Same Page Communication"})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Direct Access:"})," If the components or views are part of the same ZK page, they can be accessed directly via their component IDs or by traversing the component tree. For instance, using ",(0,t.jsx)(n.code,{children:"getFellow()"})," or ",(0,t.jsx)(n.code,{children:"getParent()"})," methods to access another component."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Event Binding:"})," Another way is to use ZK\u2019s event-driven model, where one component can send an event that another component is listening for. This can be done using ",(0,t.jsx)(n.code,{children:"sendEvent()"}),", ",(0,t.jsx)(n.code,{children:"postEvent()"}),", or by using custom event listeners."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Data Binding:"})," If you are using MVVM, data binding is a powerful way to automatically propagate changes across views without manually handling events."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.h4,{id:"12-cross-window-communication",children:["1.2 ",(0,t.jsx)(n.strong,{children:"Cross-Window Communication"})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Execution Queues:"})," ZK provides an ",(0,t.jsx)(n.code,{children:"ExecutionQueue"})," mechanism that allows communication across different browser windows or tabs. By pushing messages to a named queue, other windows can subscribe to receive these messages and act accordingly."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Server-Push:"})," ZK supports server-push, which allows the server to send updates to the client asynchronously. This can be useful when changes in one window need to be reflected in another without requiring a manual refresh."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Client-Side JavaScript:"})," Sometimes, using JavaScript to handle communication across windows can be effective, especially for tasks like opening new windows and passing data between them using ",(0,t.jsx)(n.code,{children:"window.opener"})," or ",(0,t.jsx)(n.code,{children:"window.postMessage()"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Custom Event Handling:"})," You can define custom events that can be fired across windows or tabs using ZK\u2019s event system. This allows for a high degree of control and customization."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.h3,{id:"2-impact-of-mvvm-and-mvc-patterns-on-communication",children:["2. ",(0,t.jsx)(n.strong,{children:"Impact of MVVM and MVC Patterns on Communication"})]}),"\n",(0,t.jsx)(n.p,{children:"The choice between MVVM and MVC patterns in ZK affects how communication across views or windows is managed. While both patterns can be used to build ZK applications, they differ fundamentally in how data and actions are handled."}),"\n",(0,t.jsxs)(n.h4,{id:"21-mvc-pattern",children:["2.1 ",(0,t.jsx)(n.strong,{children:"MVC Pattern"})]}),"\n",(0,t.jsx)(n.p,{children:"In the MVC pattern:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Controller-Centric Communication:"})," The controller acts as the central hub for communication between the view and the model. Communication between different views or windows typically involves the controller coordinating these interactions."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Manual Data Propagation:"})," Any updates to the model or the view often require manual handling, such as explicitly setting attributes or invoking methods to update the UI."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Event Handling:"})," Events are captured in the controller and appropriate actions are taken to update the view or model. If communication is needed between multiple controllers (across different windows), the controllers must be aware of each other or use shared services."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Complex Interactions:"})," Cross-window communication can be more complex in MVC because the controller must manage state across multiple views and ensure consistency."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.h4,{id:"22-mvvm-pattern",children:["2.2 ",(0,t.jsx)(n.strong,{children:"MVVM Pattern"})]}),"\n",(0,t.jsx)(n.p,{children:"In the MVVM pattern:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Data Binding:"})," MVVM leverages ZK\u2019s data binding features, which allows the view to automatically reflect changes in the ViewModel and vice versa. This simplifies communication between views because changes in the ViewModel are propagated automatically."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"ViewModel-Centric Communication:"})," In MVVM, the ViewModel often acts as the mediator for interactions. Different ViewModels can communicate by sharing a common service or using event listeners to respond to changes."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Less Boilerplate Code:"})," MVVM reduces the need for explicit handling of UI updates, as most of the communication is managed through data binding and observer patterns. This makes cross-window communication more seamless, especially when dealing with data changes."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Event Handling:"})," Similar to MVC, events can be used to trigger actions, but in MVVM, these are often bound directly to methods in the ViewModel, reducing the need for manual intervention."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.h3,{id:"3-best-practices",children:["3. ",(0,t.jsx)(n.strong,{children:"Best Practices"})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Use Data Binding in MVVM:"})," When following the MVVM pattern, leverage data binding to minimize the need for manual updates across views. This ensures that changes in the data model automatically reflect in all bound views."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Minimize Direct Component Access:"})," Avoid directly manipulating components in other views or windows. Instead, use events or shared ViewModels to manage state and communication."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Use Execution Queues for Cross-Window Communication:"})," For robust cross-window communication, consider using ZK\u2019s ",(0,t.jsx)(n.code,{children:"ExecutionQueue"}),". It is designed to handle such scenarios and can simplify the communication process."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Decouple Logic in MVC:"})," In MVC, try to decouple the logic as much as possible by using service layers or utility classes that can be accessed by multiple controllers. This reduces dependencies and makes the application easier to maintain."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Leverage Server-Push for Real-Time Updates:"})," If your application requires real-time communication across views or windows, consider using ZK\u2019s server-push technology to keep all views in sync without needing manual refreshes."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Conclusion:"})}),"\n",(0,t.jsx)(n.p,{children:"Communicating across different views or windows in ZK is a common requirement that can be achieved through various methods, depending on the design pattern employed. While the MVC pattern relies more on the controller for managing communication, the MVVM pattern leverages data binding and ViewModels for a more automated approach. Understanding these patterns and using the right tools and techniques can significantly enhance the interactivity and responsiveness of your ZK applications."}),"\n",(0,t.jsxs)(n.h3,{id:"examples-of-executionqueue-usage-in-zk",children:["Examples of ",(0,t.jsx)(n.code,{children:"ExecutionQueue"})," Usage in ZK"]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"ExecutionQueue"})," in ZK is a powerful mechanism that allows communication between different sessions, windows, or tabs. It works by letting you send messages to a named queue, and any listeners that are subscribed to this queue can react to these messages. This is particularly useful for scenarios where you need to synchronize state across multiple browser windows or tabs, or even across different users' sessions."]}),"\n",(0,t.jsx)(n.h4,{id:"1-basic-example-cross-window-communication",children:(0,t.jsx)(n.strong,{children:"1. Basic Example: Cross-Window Communication"})}),"\n",(0,t.jsx)(n.p,{children:"Suppose you have a ZK application where you want to notify all open windows when a specific action occurs (like updating data on the server)."}),"\n",(0,t.jsx)(n.h5,{id:"step-1-sending-a-message-to-the-executionqueue",children:(0,t.jsx)(n.strong,{children:"Step 1: Sending a Message to the ExecutionQueue"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'import org.zkoss.zk.ui.Executions;\nimport org.zkoss.zk.ui.sys.ExecutionCtrl;\nimport org.zkoss.zk.ui.util.Clients;\n\npublic class UpdateDataViewModel {\n\n    public void updateData() {\n        // Perform some data update operation\n        performDataUpdate();\n\n        // Send a message to the queue\n        String queueName = "dataUpdateQueue";\n        String message = "Data has been updated!";\n        ExecutionCtrl execCtrl = (ExecutionCtrl) Executions.getCurrent();\n        execCtrl.getExecutionInfo().getQueue(queueName).publish(message);\n    }\n\n    private void performDataUpdate() {\n        // Your data update logic goes here\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h5,{id:"step-2-listening-for-messages-in-another-window",children:(0,t.jsx)(n.strong,{children:"Step 2: Listening for Messages in Another Window"})}),"\n",(0,t.jsxs)(n.p,{children:["In the other windows or views that need to listen for updates, you would subscribe to the ",(0,t.jsx)(n.code,{children:"ExecutionQueue"})," like this:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'import org.zkoss.zk.ui.event.EventListener;\nimport org.zkoss.zk.ui.event.EventQueues;\nimport org.zkoss.zk.ui.util.Clients;\n\npublic class DataListenerViewModel {\n\n    public DataListenerViewModel() {\n        String queueName = "dataUpdateQueue";\n        EventQueues.lookup(queueName).subscribe(new EventListener<String>() {\n            @Override\n            public void onEvent(String message) {\n                // Handle the message received from the queue\n                Clients.showNotification(message);\n                refreshView();\n            }\n        });\n    }\n\n    private void refreshView() {\n        // Logic to refresh the view goes here\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h5,{id:"explanation-1",children:(0,t.jsx)(n.strong,{children:"Explanation:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Sending Messages:"})," The ",(0,t.jsx)(n.code,{children:"updateData()"})," method updates some data and then sends a message to the ",(0,t.jsx)(n.code,{children:"ExecutionQueue"})," named ",(0,t.jsx)(n.code,{children:"dataUpdateQueue"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Subscribing to the Queue:"})," In the constructor of ",(0,t.jsx)(n.code,{children:"DataListenerViewModel"}),", we subscribe to the ",(0,t.jsx)(n.code,{children:"ExecutionQueue"})," with the same name. When a message is published to this queue, the listener will receive it and can react accordingly."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"2-advanced-example-user-specific-communication",children:(0,t.jsx)(n.strong,{children:"2. Advanced Example: User-Specific Communication"})}),"\n",(0,t.jsx)(n.p,{children:"Let's say you want to send a message only to a specific user's session, like notifying them of a private message."}),"\n",(0,t.jsx)(n.h5,{id:"step-1-creating-a-user-specific-queue",children:(0,t.jsx)(n.strong,{children:"Step 1: Creating a User-Specific Queue"})}),"\n",(0,t.jsx)(n.p,{children:"Each user could have a unique queue based on their session ID or username."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'import org.zkoss.zk.ui.Executions;\nimport org.zkoss.zk.ui.util.Clients;\n\npublic class NotificationService {\n\n    public void notifyUser(String username, String message) {\n        String queueName = "userQueue_" + username;\n        EventQueues.lookup(queueName).publish(message);\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h5,{id:"step-2-subscribing-to-the-user-specific-queue",children:(0,t.jsx)(n.strong,{children:"Step 2: Subscribing to the User-Specific Queue"})}),"\n",(0,t.jsx)(n.p,{children:"In the user's session or window, you would subscribe to their specific queue."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'import org.zkoss.zk.ui.event.EventListener;\nimport org.zkoss.zk.ui.event.EventQueues;\nimport org.zkoss.zk.ui.util.Clients;\n\npublic class UserViewModel {\n\n    public UserViewModel(String username) {\n        String queueName = "userQueue_" + username;\n        EventQueues.lookup(queueName).subscribe(new EventListener<String>() {\n            @Override\n            public void onEvent(String message) {\n                // Notify the user with a custom message\n                Clients.showNotification("Private Message: " + message);\n            }\n        });\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h5,{id:"explanation-2",children:(0,t.jsx)(n.strong,{children:"Explanation:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Notify Specific Users:"})," The ",(0,t.jsx)(n.code,{children:"NotificationService"})," can send messages to a user-specific queue. This queue can be uniquely identified by the user's username."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"User Subscription:"})," The ",(0,t.jsx)(n.code,{children:"UserViewModel"})," subscribes to their own queue, ensuring that they only receive messages intended for them."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"3-real-time-notifications-example",children:(0,t.jsx)(n.strong,{children:"3. Real-Time Notifications Example"})}),"\n",(0,t.jsx)(n.p,{children:"Imagine a real-time collaborative application where users need to be notified when others make changes to shared data."}),"\n",(0,t.jsx)(n.h5,{id:"step-1-publishing-collaborative-updates",children:(0,t.jsx)(n.strong,{children:"Step 1: Publishing Collaborative Updates"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'public class CollaborationService {\n\n    public void publishUpdate(String docId, String updateInfo) {\n        String queueName = "docUpdateQueue_" + docId;\n        EventQueues.lookup(queueName, EventQueues.APPLICATION, true).publish(updateInfo);\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h5,{id:"step-2-subscribing-to-updates-for-a-specific-document",children:(0,t.jsx)(n.strong,{children:"Step 2: Subscribing to Updates for a Specific Document"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'import org.zkoss.zk.ui.event.EventListener;\nimport org.zkoss.zk.ui.event.EventQueues;\nimport org.zkoss.zk.ui.util.Clients;\n\npublic class DocumentViewModel {\n\n    public DocumentViewModel(String docId) {\n        String queueName = "docUpdateQueue_" + docId;\n        EventQueues.lookup(queueName, EventQueues.APPLICATION, true).subscribe(new EventListener<String>() {\n            @Override\n            public void onEvent(String updateInfo) {\n                // Handle the update for the document\n                Clients.showNotification("Document updated: " + updateInfo);\n                refreshDocumentView();\n            }\n        });\n    }\n\n    private void refreshDocumentView() {\n        // Logic to refresh the document view goes here\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h5,{id:"explanation-3",children:(0,t.jsx)(n.strong,{children:"Explanation:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Document-Specific Queues:"})," Each document being edited has its own queue (e.g., ",(0,t.jsx)(n.code,{children:"docUpdateQueue_123"})," for document ID 123)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Publishing Updates:"})," The ",(0,t.jsx)(n.code,{children:"CollaborationService"})," sends updates to the queue associated with the document being modified."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Subscribing to Updates:"})," Each user's view of the document subscribes to its specific queue, ensuring they receive real-time updates as other users make changes."]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"summary",children:(0,t.jsx)(n.strong,{children:"Summary"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"ExecutionQueue"})," in ZK allows for powerful communication across different views, windows, or even sessions."]}),"\n",(0,t.jsx)(n.li,{children:"It is useful for scenarios requiring synchronization between multiple browser windows, such as updating UI elements, sending notifications, or coordinating state changes."}),"\n",(0,t.jsx)(n.li,{children:"Depending on the use case, queues can be shared globally, specific to users, or specific to particular documents or resources."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["By effectively using ",(0,t.jsx)(n.code,{children:"ExecutionQueue"}),", you can build responsive, collaborative applications that keep users in sync with the latest changes happening across different parts of your ZK application."]}),"\n",(0,t.jsxs)(n.p,{children:["In ZK, ",(0,t.jsx)(n.code,{children:"BindUtils.postGlobalCommand()"})," is specifically designed for use in the MVVM pattern. It allows a ViewModel to post a command that can be received by another ViewModel, even across different views. This mechanism relies on the MVVM data-binding infrastructure, where commands are typically annotated with ",(0,t.jsx)(n.code,{children:"@GlobalCommand"})," in the receiving ViewModel."]}),"\n",(0,t.jsxs)(n.p,{children:["However, if you are working with an MVVM pattern on the sending side and an MVC pattern on the receiving side, ",(0,t.jsx)(n.code,{children:"BindUtils.postGlobalCommand()"})," won't directly work in the MVC context because MVC controllers don't use the same annotation-based command mechanism as MVVM."]}),"\n",(0,t.jsx)(n.h3,{id:"how-to-make-mvvm-and-mvc-communicate",children:(0,t.jsx)(n.strong,{children:"How to Make MVVM and MVC Communicate"})}),"\n",(0,t.jsx)(n.p,{children:"To communicate between an MVVM-based ViewModel and an MVC-based controller, you need to use a different approach. Here\u2019s how you can achieve communication from MVVM to MVC:"}),"\n",(0,t.jsx)(n.h4,{id:"1-use-events-instead-of-global-commands",children:(0,t.jsx)(n.strong,{children:"1. Use Events Instead of Global Commands"})}),"\n",(0,t.jsx)(n.p,{children:"Since MVC relies on event handling rather than commands, you can use the ZK event system to send events from the ViewModel to a controller."}),"\n",(0,t.jsx)(n.h5,{id:"step-1-posting-a-custom-event-in-mvvm",children:(0,t.jsx)(n.strong,{children:"Step 1: Posting a Custom Event in MVVM"})}),"\n",(0,t.jsx)(n.p,{children:"In your MVVM ViewModel, you can post a custom event to a specific component or a global event to all components using the event system."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'import org.zkoss.bind.BindUtils;\nimport org.zkoss.zk.ui.event.Event;\nimport org.zkoss.zk.ui.event.Events;\nimport org.zkoss.zk.ui.Component;\n\npublic class FirstViewModel {\n\n    public void sendData() {\n        String data = "Hello from FirstViewModel";\n        \n        // Post a global event (if the target component is known)\n        Events.postEvent("onReceiveData", someComponent, data);\n    }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"In this code:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Events.postEvent()"})," is used to send an event named ",(0,t.jsx)(n.code,{children:'"onReceiveData"'})," to ",(0,t.jsx)(n.code,{children:"someComponent"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"data"})," string is passed as the event's data, which the MVC controller can handle."]}),"\n"]}),"\n",(0,t.jsx)(n.h5,{id:"step-2-listening-for-the-event-in-mvc",children:(0,t.jsx)(n.strong,{children:"Step 2: Listening for the Event in MVC"})}),"\n",(0,t.jsxs)(n.p,{children:["In your MVC controller, you listen for the ",(0,t.jsx)(n.code,{children:'"onReceiveData"'})," event using the ",(0,t.jsx)(n.code,{children:"addEventListener"})," method."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'import org.zkoss.zk.ui.event.Event;\nimport org.zkoss.zk.ui.event.EventListener;\nimport org.zkoss.zk.ui.util.GenericForwardComposer;\n\npublic class SecondController extends GenericForwardComposer<Component> {\n\n    @Override\n    public void doAfterCompose(Component comp) throws Exception {\n        super.doAfterCompose(comp);\n\n        // Add an event listener for "onReceiveData"\n        comp.addEventListener("onReceiveData", new EventListener<Event>() {\n            @Override\n            public void onEvent(Event event) throws Exception {\n                String receivedData = (String) event.getData();\n                // Process the received data\n                System.out.println("Received data: " + receivedData);\n            }\n        });\n    }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"In this code:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"SecondController"})," listens for the ",(0,t.jsx)(n.code,{children:'"onReceiveData"'})," event."]}),"\n",(0,t.jsxs)(n.li,{children:["When the event is fired, the ",(0,t.jsx)(n.code,{children:"onEvent()"})," method processes the data received from the ViewModel."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"summary-1",children:(0,t.jsx)(n.strong,{children:"Summary"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"MVVM to MVC Communication"}),": ",(0,t.jsx)(n.code,{children:"BindUtils.postGlobalCommand()"})," won't work directly with MVC controllers because they don't recognize the command annotations used in MVVM. Instead, use ",(0,t.jsx)(n.code,{children:"Events.postEvent()"})," to send events."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Receiving in MVC"}),": In the MVC controller, use ",(0,t.jsx)(n.code,{children:"addEventListener()"})," to listen for these events and process the data accordingly."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"By using ZK\u2019s event system, you can effectively enable communication between MVVM and MVC components, allowing for interaction between different design patterns within the same application."})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>a});var t=s(6540);const i={},o=t.createContext(i);function r(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);