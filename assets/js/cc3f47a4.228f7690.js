"use strict";(self.webpackChunktkbook=self.webpackChunktkbook||[]).push([[3278],{530:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>o,toc:()=>d});var s=i(4848),r=i(8453);const t={},l="UI Refresh in ZK Framework: MVC vs MVVM",o={id:"ZK/Ui Update",title:"UI Refresh in ZK Framework: MVC vs MVVM",description:"In ZK, managing UI updates and refreshing the view in response to data changes is a critical aspect of building dynamic web applications. The approach to UI refresh can vary significantly depending on whether you are using the MVC (Model-View-Controller) pattern or the MVVM (Model-View-ViewModel) pattern. This document provides a detailed comparison of UI refresh strategies in both architectural patterns.",source:"@site/docs/ZK/Ui Update.md",sourceDirName:"ZK",slug:"/ZK/Ui Update",permalink:"/tkbook/docs/ZK/Ui Update",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Reusable Components",permalink:"/tkbook/docs/ZK/Reusable Components"},next:{title:"ZUL Page Lifecycle",permalink:"/tkbook/docs/ZK/ZUL Page Lifecycle"}},a={},d=[{value:"<strong>1. Introduction</strong>",id:"1-introduction",level:2},{value:"<strong>2. MVC (Model-View-Controller)</strong>",id:"2-mvc-model-view-controller",level:2},{value:"<strong>Overview</strong>",id:"overview",level:3},{value:"<strong>UI Refresh Mechanism</strong>",id:"ui-refresh-mechanism",level:3},{value:"<strong>ZUL File</strong>",id:"zul-file",level:4},{value:"<strong>Java Controller</strong>",id:"java-controller",level:4},{value:"<strong>3. MVVM (Model-View-ViewModel)</strong>",id:"3-mvvm-model-view-viewmodel",level:2},{value:"<strong>Overview</strong>",id:"overview-1",level:3},{value:"<strong>UI Refresh Mechanism</strong>",id:"ui-refresh-mechanism-1",level:3},{value:"<strong>ZUL File</strong>",id:"zul-file-1",level:4},{value:"<strong>Java ViewModel</strong>",id:"java-viewmodel",level:4},{value:"<strong>4. Comparison</strong>",id:"4-comparison",level:2},{value:"<strong>5. Conclusion</strong>",id:"5-conclusion",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"ui-refresh-in-zk-framework-mvc-vs-mvvm",children:"UI Refresh in ZK Framework: MVC vs MVVM"})}),"\n",(0,s.jsx)(n.p,{children:"In ZK, managing UI updates and refreshing the view in response to data changes is a critical aspect of building dynamic web applications. The approach to UI refresh can vary significantly depending on whether you are using the MVC (Model-View-Controller) pattern or the MVVM (Model-View-ViewModel) pattern. This document provides a detailed comparison of UI refresh strategies in both architectural patterns."}),"\n",(0,s.jsx)(n.h2,{id:"1-introduction",children:(0,s.jsx)(n.strong,{children:"1. Introduction"})}),"\n",(0,s.jsx)(n.p,{children:"In ZK, the UI refresh mechanism determines how and when changes in the data or model are reflected in the user interface. The primary difference between MVC and MVVM lies in how data binding and UI updates are handled."}),"\n",(0,s.jsx)(n.h2,{id:"2-mvc-model-view-controller",children:(0,s.jsx)(n.strong,{children:"2. MVC (Model-View-Controller)"})}),"\n",(0,s.jsx)(n.h3,{id:"overview",children:(0,s.jsx)(n.strong,{children:"Overview"})}),"\n",(0,s.jsx)(n.p,{children:"In the MVC pattern, the UI refresh is managed manually in the controller. The controller is responsible for responding to user interactions, updating the model, and reflecting changes in the view."}),"\n",(0,s.jsx)(n.h3,{id:"ui-refresh-mechanism",children:(0,s.jsx)(n.strong,{children:"UI Refresh Mechanism"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Manual Updates"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Controller Role"}),": In MVC, the controller handles the logic to manually update the UI components based on changes in the data or user actions."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Explicit Calls"}),": You need to explicitly update the view by calling methods on UI components to reflect changes."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Event Handling"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Event Listeners"}),": Events are handled in the controller methods. For instance, clicking a button triggers a method in the controller, which then updates the relevant UI components."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Example"}),":"]}),"\n",(0,s.jsx)(n.h4,{id:"zul-file",children:(0,s.jsx)(n.strong,{children:"ZUL File"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<window title="MVC Example" border="normal" apply="com.example.MyMvcController">\n    <vbox>\n        <label id="lblMessage" value="Hello, MVC!" />\n        <textbox id="txtInput" />\n        <button id="btnSubmit" label="Submit" onClick="onClickSubmit" />\n    </vbox>\n</window>\n'})}),"\n",(0,s.jsx)(n.h4,{id:"java-controller",children:(0,s.jsx)(n.strong,{children:"Java Controller"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'package com.example;\n\nimport org.zkoss.zk.ui.Component;\nimport org.zkoss.zk.ui.select.SelectorComposer;\nimport org.zkoss.zk.ui.select.annotation.Wire;\nimport org.zkoss.zul.Label;\nimport org.zkoss.zul.Textbox;\n\npublic class MyMvcController extends SelectorComposer<Component> {\n\n    @Wire\n    private Label lblMessage;\n\n    @Wire\n    private Textbox txtInput;\n\n    public void onClickSubmit() {\n        // Manual data handling\n        String input = txtInput.getValue();\n        lblMessage.setValue("Hello, " + input);\n    }\n}\n'})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Pros and Cons"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Pros"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Full control over when and how the UI is updated."}),"\n",(0,s.jsx)(n.li,{children:"Suitable for simpler applications where manual management is feasible."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cons"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Requires explicit code for every update, leading to more boilerplate code."}),"\n",(0,s.jsx)(n.li,{children:"Can become cumbersome and error-prone in large applications with complex UI interactions."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"3-mvvm-model-view-viewmodel",children:(0,s.jsx)(n.strong,{children:"3. MVVM (Model-View-ViewModel)"})}),"\n",(0,s.jsx)(n.h3,{id:"overview-1",children:(0,s.jsx)(n.strong,{children:"Overview"})}),"\n",(0,s.jsx)(n.p,{children:"In the MVVM pattern, the UI refresh is managed through data binding between the View and the ViewModel. The ViewModel is responsible for exposing data and commands that the View binds to, facilitating automatic updates."}),"\n",(0,s.jsx)(n.h3,{id:"ui-refresh-mechanism-1",children:(0,s.jsx)(n.strong,{children:"UI Refresh Mechanism"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Automatic Data Binding"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ViewModel Role"}),": In MVVM, the ViewModel exposes properties and commands. Changes in these properties are automatically reflected in the View due to data binding."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Two-Way Binding"}),": Binding can be two-way, meaning changes in the UI automatically update the ViewModel and vice versa."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Declarative UI Binding"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ZUL Binding"}),": Use the ",(0,s.jsx)(n.code,{children:"@bind"})," annotation in ZUL files to create bindings between UI components and ViewModel properties."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Example"}),":"]}),"\n",(0,s.jsx)(n.h4,{id:"zul-file-1",children:(0,s.jsx)(n.strong,{children:"ZUL File"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<window title="MVVM Example" border="normal" apply="org.zkoss.bind.BindComposer">\n    <vbox>\n        <label value="@bind(vm.message)" />\n        <textbox value="@bind(vm.inputMessage)" />\n        <button label="Submit" onClick="@command(\'updateMessage\')" />\n    </vbox>\n</window>\n'})}),"\n",(0,s.jsx)(n.h4,{id:"java-viewmodel",children:(0,s.jsx)(n.strong,{children:"Java ViewModel"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'package com.example;\n\nimport org.zkoss.bind.BindComposer;\nimport org.zkoss.bind.annotation.Command;\nimport org.zkoss.bind.annotation.NotifyChange;\n\npublic class MyViewModel {\n\n    private String message = "Hello, MVVM!";\n    private String inputMessage;\n\n    public String getMessage() {\n        return message;\n    }\n\n    public String getInputMessage() {\n        return inputMessage;\n    }\n\n    public void setInputMessage(String inputMessage) {\n        this.inputMessage = inputMessage;\n    }\n\n    @Command\n    @NotifyChange("message")\n    public void updateMessage() {\n        message = "Hello, " + inputMessage;\n    }\n}\n'})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Pros and Cons"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Pros"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Simplifies UI updates with automatic data binding."}),"\n",(0,s.jsx)(n.li,{children:"Reduces boilerplate code and improves maintainability."}),"\n",(0,s.jsx)(n.li,{children:"Facilitates better separation of concerns between UI and business logic."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cons"}),":","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Can have a steeper learning curve, especially for developers new to data binding concepts."}),"\n",(0,s.jsx)(n.li,{children:"Requires understanding and managing binding annotations and their interactions."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"4-comparison",children:(0,s.jsx)(n.strong,{children:"4. Comparison"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Aspect"}),(0,s.jsx)(n.th,{children:"MVC"}),(0,s.jsx)(n.th,{children:"MVVM"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Data Binding"})}),(0,s.jsx)(n.td,{children:"Manual, explicit updates"}),(0,s.jsxs)(n.td,{children:["Automatic, declarative with ",(0,s.jsx)(n.code,{children:"@bind"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"UI Updates"})}),(0,s.jsx)(n.td,{children:"Managed explicitly in controller code"}),(0,s.jsx)(n.td,{children:"Managed automatically through data binding"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Event Handling"})}),(0,s.jsx)(n.td,{children:"Handled explicitly in controller methods"}),(0,s.jsxs)(n.td,{children:["Handled declaratively through ",(0,s.jsx)(n.code,{children:"@command"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Code Complexity"})}),(0,s.jsx)(n.td,{children:"Higher, requires manual updates and wiring"}),(0,s.jsx)(n.td,{children:"Lower, less boilerplate due to automatic binding"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Separation of Concerns"})}),(0,s.jsx)(n.td,{children:"Moderate, manual management of UI and logic"}),(0,s.jsx)(n.td,{children:"High, with clear separation of View and ViewModel"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"5-conclusion",children:(0,s.jsx)(n.strong,{children:"5. Conclusion"})}),"\n",(0,s.jsx)(n.p,{children:"Choosing between MVC and MVVM for managing UI refresh in ZK depends on the complexity of your application and your preferences for managing data updates and UI interactions:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"MVC"})," provides more control and flexibility but requires manual handling of UI updates and data synchronization."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"MVVM"})," simplifies UI management with automatic data binding and reduces boilerplate code, making it a good choice for more complex applications with extensive data binding needs."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>o});var s=i(6540);const r={},t=s.createContext(r);function l(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);